import { JwtService } from './jwt.service';
import { ConfigService } from './config.service';
import { LoggerService } from './logger.service';
import { JwtTypes } from 'src/enums/jwt-types.enum';
import { JwtBlackListService } from './jwt-blacklist.service';
import { calculateTokenTTL } from 'src/functions/token/calculate-token-ttl';
import { HttpError } from 'src/errors/http-error.class';
import { authErrors } from 'src/messages/auth.error.messages';
import { tokenPurposes } from 'src/constants/token-purposes.constants';

export class EmailValidationTokenService {
    constructor(
        private readonly configService: ConfigService,
        private readonly jwtService: JwtService,
        private readonly jwtBlacklistService: JwtBlackListService,
        private readonly loggerService: LoggerService,
    ) {}

    generate(userEmail: string): string;
    generate(userEmail: string, options: { meta: true }): { token: string; jti: string };
    generate(
        userEmail: string,
        options?: { meta?: boolean },
    ): string | { token: string; jti: string } {
        const expTime = this.configService.JWT_EMAIL_VALIDATION_EXP_TIME;
        const { token, jti } = this.jwtService.generate(expTime, {
            purpose: tokenPurposes.EMAIL_VALIDATION,
            email: userEmail,
        });
        this.loggerService.info(`Email validation token ${jti} generated, expires at ${expTime}`);

        if (options?.meta) {
            return { token, jti };
        }
        return token;
    }

    async blacklist(jti: string, tokenExp: number): Promise<void> {
        const remainingTokenTTL = calculateTokenTTL(tokenExp);
        if (remainingTokenTTL > 0) {
            this.loggerService.info(`Email validation token "${jti}" blacklisted`);
            await this.jwtBlacklistService.blacklist(
                JwtTypes.emailValidation,
                jti,
                remainingTokenTTL,
            );
        } else {
            this.loggerService.info(
                `Email validation token "${jti}" already expired, skipping blacklisting`,
            );
        }
    }

    async consume(token: string): Promise<string> {
        // token was generated by this server
        const payload = this.jwtService.verify<{ email: string }>(token);
        if (!payload) {
            this.loggerService.error('Invalid token, not generated by this server');
            throw HttpError.unAuthorized(authErrors.INVALID_TOKEN);
        }
        // email must be in token
        const emailInToken = payload.email;
        if (!emailInToken) {
            this.loggerService.error('Email not in token');
            throw HttpError.unAuthorized(authErrors.INVALID_TOKEN);
        }
        // correct purpose
        const validPurpose = payload.purpose === tokenPurposes.EMAIL_VALIDATION;
        if (!validPurpose) {
            this.loggerService.error(`Invalid token purpose: ${payload.purpose}`);
            throw HttpError.unAuthorized(authErrors.INVALID_TOKEN);
        }
        // token is not blacklisted
        const tokenIsBlacklisted = await this.jwtBlacklistService.tokenInBlacklist(
            JwtTypes.emailValidation,
            payload.jti,
        );
        if (tokenIsBlacklisted) {
            this.loggerService.error('Token is blacklisted');
            throw HttpError.unAuthorized(authErrors.INVALID_TOKEN);
        }
        // single-use token
        await this.blacklist(payload.jti, payload.exp!);
        return payload.email;
    }
}
