import { NextFunction, Request, Response } from "express";
import { Model } from "mongoose";
import { canAccess } from "./helpers/can-access.helper";
import { FORBIDDEN_MESSAGE } from "@root/rules/errors/messages/error.messages";
import { handleError } from "@root/common/handlers/error.handler";
import { HTTP_STATUS_CODE, TOKEN_PURPOSES } from "@root/rules/constants";
import { IUser } from "@root/interfaces";
import { JwtBlackListService, JwtService, LoggerService } from "@root/services";
import { UserRole } from "@root/types/user";

export const rolesMiddlewareFactory = (
    minRoleRequired: UserRole,
    userModel: Model<IUser>,
    loggerService: LoggerService,
    jwtService: JwtService,
    jwtBlacklistService: JwtBlackListService,
) => {
    return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
            loggerService.debug('Roles Middleware');
            const invalidBearerTokenMessageToClient = 'Invalid bearer token';

            // token not provided
            const authorizationHeader = req.header('authorization');
            if (!authorizationHeader) {
                loggerService.error('Access denied, no token provided');
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: 'No token provided' });
                return;
            }

            // token is not a bearer token
            const isBearerToken = authorizationHeader.startsWith('Bearer');
            if (!isBearerToken) {
                loggerService.error('Provided token is not a bearer token');
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            const token = authorizationHeader.split(' ').at(1) || '';

            // token is not valid
            const payload = jwtService.verify<{ id: string }>(token);
            if (!payload) {
                loggerService.error('Token sent is not valid or not generated by this server seed');
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            // token purpose is not the expected
            const tokenPurpose = payload.purpose;
            if (tokenPurpose !== TOKEN_PURPOSES.SESSION) {
                loggerService.error(`Token purpose "${tokenPurpose}" is not the expected purpose`);
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            // token is blacklisted
            const tokenIsBlacklisted = await jwtBlacklistService.isBlacklisted(payload.jti);
            if (tokenIsBlacklisted) {
                loggerService.error(`Token is blacklisted`);
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            // user id not in token
            const userId = payload.id;
            if (!userId) {
                loggerService.error('User id not in token');
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            // user in token not exists
            const user = await userModel.findById(userId).exec();
            if (!user) {
                loggerService.error('User in token does not exist');
                res.status(HTTP_STATUS_CODE.UNAUTHORIZED).json({ error: invalidBearerTokenMessageToClient });
                return;
            }

            if (canAccess(minRoleRequired, user.role)) {
                loggerService.info(`Access granted for user ${userId} with role "${user.role}"`)
                Object.defineProperties(req, {
                    userId: { value: userId },
                    userRole: { value: user.role },
                    jti: { value: payload.jti },
                    tokenExp: { value: payload.exp }
                });
                next();
            }
            else {
                loggerService.error('Access denied. Insufficient permissions')
                res.status(HTTP_STATUS_CODE.FORBIDDEN)
                    .json({ error: FORBIDDEN_MESSAGE })
                return;
            }

        } catch (error) {
            handleError(res, error, loggerService);
        }
    };
}