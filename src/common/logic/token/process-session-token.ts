import { Model } from "mongoose";
import { Request } from "express";
import { JwtTypes } from '@root/enums/jwt-types.enum';
import { JwtService } from '@root/services/jwt.service';
import { IUser } from '@root/interfaces/user/user.interface';
import { JwtBlackListService } from '@root/services/jwt-blacklist.service';
import { UserFromRequest } from '@root/interfaces/user/user-from-request.interface';
import { tokenPurposes } from '@root/common/constants/token-purposes.constants';

export async function processSessionToken(
    req: Request,
    userModel: Model<IUser>,
    jwtService: JwtService,
    jwtBlacklistService: JwtBlackListService
): Promise<{ error: string; } | UserFromRequest> {

    // token not provided
    const authorizationHeader = req.header('authorization');
    if (!authorizationHeader)
        return { error: 'Access denied, no token provided' };

    // token is not a bearer token
    const isBearerToken = authorizationHeader.startsWith('Bearer');
    if (!isBearerToken)
        return { error: 'Provided token is not a bearer token' };

    const token = authorizationHeader.split(' ').at(1) || '';

    // token is not valid
    const payload = jwtService.verify<{ id: string }>(token);
    if (!payload)
        return { error: 'Token sent is not generated by this server' };

    // token purpose is not the expected
    const tokenPurpose = payload.purpose;
    if (tokenPurpose !== tokenPurposes.SESSION)
        return { error: `Token purpose "${tokenPurpose}" is not the expected` };

    // token is blacklisted
    const tokenIsBlacklisted = await jwtBlacklistService.tokenInBlacklist(JwtTypes.session, payload.jti);
    if (tokenIsBlacklisted)
        return { error: `Token is blacklisted` };

    // user id not in token
    const userId = payload.id;
    if (!userId)
        return { error: 'User id not in token' };

    // user in token not exists
    const user = await userModel.findById(userId).exec();
    if (!user)
        return { error: 'User in token does not exist' };

    return {
        id: user.id,
        role: user.role,
        jti: payload.jti,
        tokenExp: payload.exp!,
    }
}