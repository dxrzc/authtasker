import { processSessionToken } from '@logic/token/process-session-token';

describe('processSessionToken', () => {
    const jwtService = { verify: jest.fn() };
    const jwtBlacklistService = { tokenInBlacklist: jest.fn() };
    const userModel = { findById: jest.fn() };
    const req = { header: jest.fn() } as any;

    test('returns error when no authorization header', async () => {
        req.header.mockReturnValue(undefined);
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'Access denied, no token provided' });
    });

    test('returns error when not a bearer token', async () => {
        req.header.mockReturnValue('Token abc');
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'Provided token is not a bearer token' });
    });

    test('returns error when jwt is invalid', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue(undefined);
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'Token sent is not generated by this server' });
    });

    test('returns error for wrong token purpose', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue({ purpose: 'reset' });
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'Token purpose "reset" is not the expected' });
    });

    test('returns error if token is blacklisted', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue({ purpose: 'session', jti: 'abc' });
        jwtBlacklistService.tokenInBlacklist.mockResolvedValue(true);
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'Token is blacklisted' });
    });

    test('returns error if user id is missing', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue({ purpose: 'session', jti: 'abc' });
        jwtBlacklistService.tokenInBlacklist.mockResolvedValue(false);
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'User id not in token' });
    });

    test('returns error if user not found', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue({ purpose: 'session', jti: 'abc', id: 'user123' });
        jwtBlacklistService.tokenInBlacklist.mockResolvedValue(false);
        userModel.findById.mockReturnValue({ exec: () => null });
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({ error: 'User in token does not exist' });
    });

    test('returns user info if all checks pass', async () => {
        req.header.mockReturnValue('Bearer xyz');
        jwtService.verify.mockReturnValue({ purpose: 'session', jti: 'abc', id: 'user123', exp: 9999 });
        jwtBlacklistService.tokenInBlacklist.mockResolvedValue(false);
        userModel.findById.mockReturnValue({ exec: () => ({ id: 'user123', role: 'editor' }) });
        const result = await processSessionToken(req, userModel as any, jwtService as any, jwtBlacklistService as any);
        expect(result).toEqual({
            id: 'user123',
            role: 'editor',
            jti: 'abc',
            tokenExp: 9999,
        });
    });
});  